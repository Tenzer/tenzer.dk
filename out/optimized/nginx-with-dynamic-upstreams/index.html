<!DOCTYPE html><html lang=en><head prefix="og: http://ogp.me/ns#"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Nginx with dynamic upstreams - Tenzer.dk</title><meta name=description content="The personal website and blog for Jeppe Fihl-Pearson about open source technologies and photography."><meta name=generator content="Hugo 0.80.0"><style>body{background-color:#ecf0f1;color:#2c3e50;font-family:Georgia,serif;font-size:20px;line-height:1.6em;margin:0}a{color:#e74c3c;text-decoration:none}a h1{color:#2c3e50}hr{color:#8c97a1}header{background:#2c3e50;color:#ecf0f1;text-align:left}.header-container{margin:auto;max-width:700px;padding:10px}#logo{margin:10px 0;max-height:60px;max-width:100%}nav{display:-webkit-flex;display:flex;font-size:1rem;margin-bottom:20px;max-width:400px}nav a{color:#e74c3c}nav a,nav span{-webkit-flex:1;flex:1}nav span.disabled{color:#8c97a1}.container{background-image:linear-gradient(rgba(44,62,80,.4),rgba(44,62,80,0));background-image:-webkit-linear-gradient(top,rgba(44,62,80,.4),rgba(44,62,80,0));background-repeat:repeat-x;background-size:auto 20px;padding-top:20px}.content{margin:auto;max-width:700px;padding:0 10px}.content img{display:block;margin:auto;max-width:100%}.posted-date{color:#8c97a1;font-size:1rem;margin-top:0}h1{line-height:1;margin-bottom:.5rem}pre{border:1px dashed #cfd9db;line-height:1.25em;max-width:700px;overflow:auto;padding:5px 10px}pre code{background-color:inherit;border:none;padding:0}code{background-color:#f5f7f7;border:1px dashed #cfd9db;padding:5px}blockquote{border-left:3px solid #507192;color:#3e5871;font-style:italic;margin-left:20px;padding-left:10px}ul li{list-style-type:circle}.admonition-title{font-weight:700}.admonition{border:1px solid #2c3e50;border-radius:3px;margin:20px 0;padding:0 5px}.admonition p:first-child{margin-top:5px}.admonition p:last-child{margin-bottom:5px}.admonition.attention,.admonition.warning{background-color:#ffd34e}footer{font-size:15px;margin:auto;max-width:700px;text-align:center}@media print{footer,header{display:none}}</style><link rel=logo href=/static/favicon.3dada7eb0a.svg type=image/svg+xml><link rel=icon href=/static/favicon.3dada7eb0a.svg sizes=any type=image/svg+xml><link rel=icon href=/static/favicon.e5c65e608b.png sizes=128x128 type=image/png><link rel=icon href=/static/favicon.copy.a23706216d.ico sizes="16x16 32x32 48x48 64x64" type=image/x-icon><link rel=alternate href=https://tenzer.dk/index.xml type=application/rss+xml title=Tenzer.dk><meta name=theme-color content=#2C3E50><meta property=og:type content=website><meta property=og:url content=https://tenzer.dk/nginx-with-dynamic-upstreams/ ><meta property=og:site_name content=Tenzer.dk><meta property=og:title content="Nginx with dynamic upstreams - Tenzer.dk"><meta property=og:description content="I recently made a setup at work where I had a Nginx server facing the user, which would forward requests to a service running behind an AWS Elastic Load Balancer (aka. ELB). That in itself doesn't sound like a difficult task, you just find the hostname for the ELB and point Nginx at it with a proxy_pass statement like this, right?
location / { proxy_pass http://service-1234567890.us-east-1.elb.amazonaws.com; } Test it out and - assuming the firewall/security group configuration is set up right - it should work just fine."><meta property=og:image content=https://tenzer.dk/images/logo.png><meta name=twitter:card content=summary><meta name=twitter:site content=@Tenzer><meta name=twitter:title content="Nginx with dynamic upstreams - Tenzer.dk"><meta name=twitter:description content="I recently made a setup at work where I had a Nginx server facing the user, which would forward requests to a service running behind an AWS Elastic Load Balancer (aka. ELB). That in itself doesn't sound like a difficult task, you just find the hostname for the ELB and point Nginx at it with a proxy_pass statement like this, right?
location / { proxy_pass http://service-1234567890.us-east-1.elb.amazonaws.com; } Test it out and - assuming the firewall/security group configuration is set up right - it should work just fine."><meta name=twitter:image content=https://tenzer.dk/images/logo.png></head><body><header><div class=header-container><a href=/ ><img id=logo src=/static/tenzerdk.90021cd24c.png alt="Tenzer.dk logo"></a></div></header><div class=container><div class=content><a href=/nginx-with-dynamic-upstreams/ ><h1>Nginx with dynamic upstreams</h1></a><p class=posted-date>Posted on July 26, 2015. Reading time: 5 minutes</p><p>I recently made a setup at <a href=https://www.falconsocial.com/ >work</a> where I had a Nginx server facing the user, which would forward requests to a service running behind an <a href=http://aws.amazon.com/elasticloadbalancing/ >AWS Elastic Load Balancer</a> (aka. ELB). That in itself doesn't sound like a difficult task, you just find the hostname for the ELB and point Nginx at it with a <a href=http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass>proxy_pass</a> statement like this, right?</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=color:#66d9ef>location</span> <span style=color:#e6db74>/</span> {
    <span style=color:#f92672>proxy_pass</span> <span style=color:#e6db74>http://service-1234567890.us-east-1.elb.amazonaws.com</span>;
}</code></pre></div><p>Test it out and - assuming the firewall/security group configuration is set up right - it should work just fine. Some hours later you may however find the service is no longer working, even though no changes has been made. Calling the ELB endpoint directly works just fine, but calling it through Nginx just times out.</p><h2 id=elb-endpoint-primer>ELB endpoint primer</h2><p>In order to understand why the service suddenly stopped working, a quick introduction to how the ELB works is in order:</p><p>When you create an Elastic Load Balancer you will get a DNS record back, which AWS tell you to use for all access to the service. The DNS record is a round robin DNS record pointing at two or more IP addresses - depending on how many availability zones your service makes use of. The DNS record is set up with a 60 second time to live, meaning that there's almost no caching of the record.</p><p>The short TTL allows AWS to quickly change the machines running the load balancer without having to do any elaborate virtual IP stuff in order to not disrupt service. That's also the reason they specifically tell you to not look up the hostname and then send traffic to one of the IP addresses it returns, since that IP address will stop working as a load balancer for your service some undefined time in the future.</p><h2 id=back-to-nginx>Back to Nginx</h2><p>The reason this is a problem with Nginx is because when it sees a configuration like the one posted further up, it will do the DNS request for the hostname right away, and then use the result of that until the next time the configuration is reloaded. Before that time comes around the ELB may have changed IP addresses, leaving you with a Nginx that forwards requests to some addresses that no longer serve your service.</p><h2 id=nginx-plus>Nginx Plus</h2><p>One way to solve this problem is to pay for <a href=https://www.nginx.com/products/on-the-fly-reconfiguration/ >Nginx Plus</a> which adds the <code>resolve</code> flag to the <a href=http://nginx.org/en/docs/http/ngx_http_upstream_module.html#server><code>server</code></a> directive in an <code>upstream</code> group. That will make Nginx honour the TTL of the DNS record and occasionally re-resolve the record in order to get an updated list of servers to use.</p><p>Playing <a href=https://www.nginx.com/products/pricing/ >$1.500 per year per server</a> for this feature seems like an awful lot. Of course you also get the other features Nginx Plus brings, but if you don't need them it becomes a prohibitively expensive upgrade.</p><h2 id=the-free-alternative>The free alternative</h2><p>A much cheaper option is to write the configuration like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=color:#66d9ef>resolver</span> <span style=color:#ae81ff>172</span><span style=color:#e6db74>.16.0.23</span>;
<span style=color:#66d9ef>set</span> $upstream_endpoint <span style=color:#e6db74>http://service-1234567890.us-east-1.elb.amazonaws.com</span>;
<span style=color:#66d9ef>location</span> <span style=color:#e6db74>/</span> {
    <span style=color:#f92672>proxy_pass</span> $upstream_endpoint;
}</code></pre></div><p>This will work and Nginx will honour the TTL of the DNS record and re-resolve it in case a request comes in and the cached entry has expired. But why is that?</p><p>The answer is in part found by the end of the documentation for the <a href=http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass><code>proxy_pass</code></a> directive which states:</p><blockquote><p>A server name, its port and the passed URI can also be specified using variables:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=color:#66d9ef>proxy_pass</span> <span style=color:#e6db74>http://</span>$host$uri;</code></pre></div><p>or even like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=color:#66d9ef>proxy_pass</span> $request;</code></pre></div><p>In this case, the server name is searched among the described <a href=http://nginx.org/en/docs/http/ngx_http_upstream_module.html>server groups</a>, and, if not found, is determined using a <a href=http://nginx.org/en/docs/http/ngx_http_core_module.html#resolver>resolver</a>.</p></blockquote><p>We are basically making use of the altered behaviour when we provide <code>proxy_pass</code> with a variable, but that does however require us to specify a DNS resolver in the configuration. The one used in my example should work for all servers inside AWS which run in either the default VPC or in EC2-Classic. You can always check against <code>/etc/resolv.conf</code> to figure out which DNS server AWS has provided your server with and then use that.</p><h2 id=caveat-regarding-the-forwarded-uri>Caveat regarding the forwarded URI</h2><p>If the <code>location</code> you set up in Nginx is not just <code>/</code>, then you need to be aware of <code>proxy_pass</code>'s slightly changing behaviour when given a variable as the parameter.</p><p>First things first, a quick recap of how <code>proxy_pass</code> works during normal operation:</p><p><strong>Normal behaviour</strong></p><p>Imagine we have an Nginx configuration containing this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=color:#66d9ef>location</span> <span style=color:#e6db74>/foo/</span> {
    <span style=color:#f92672>proxy_pass</span> <span style=color:#e6db74>http://127.0.0.1:8080</span>;
}</code></pre></div><p>When you make a request to the site for <code>/foo/bar/baz</code> then Nginx will forward the request to <code>http://127.0.0.1:8080/foo/bar/baz</code>. If the configuration instead looked like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=color:#66d9ef>location</span> <span style=color:#e6db74>/foo/</span> {
    <span style=color:#75715e># Note the trailing slash       ↓
</span><span style=color:#75715e></span>    <span style=color:#f92672>proxy_pass</span> <span style=color:#e6db74>http://127.0.0.1:8080/</span>;
}</code></pre></div><p>Then Nginx will strip the part of the URI specified in the <code>location</code> directive and pass the rest on to the upstream server. A request to <code>/foo/bar/baz</code> will thus be forwarded to <code>http://127.0.0.1:8080/bar/baz</code>.</p><p><strong>Changed behaviour</strong></p><p>When we use a variable as the parameter for <code>proxy_pass</code> the behaviour shown above with the trailing slash changes. Say we have this configuration:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=color:#66d9ef>resolver</span> <span style=color:#ae81ff>172</span><span style=color:#e6db74>.16.0.23</span>;
<span style=color:#66d9ef>set</span> $upstream_endpoint <span style=color:#e6db74>http://service-1234567890.us-east-1.elb.amazonaws.com/</span>;
<span style=color:#66d9ef>location</span> <span style=color:#e6db74>/foo/</span> {
    <span style=color:#f92672>proxy_pass</span> $upstream_endpoint;
}</code></pre></div><p>When you make a request for <code>/foo/bar/baz</code> for that configuration, then the forwarded request will instead go to <code>/</code> and not <code>/bar/baz</code> as expected.</p><p>The workaround for this is to remove the trailing slash from the upstream endpoint, and then rewrite it manually like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nginx data-lang=nginx><span style=color:#66d9ef>resolver</span> <span style=color:#ae81ff>172</span><span style=color:#e6db74>.16.0.23</span>;
<span style=color:#66d9ef>set</span> $upstream_endpoint <span style=color:#e6db74>http://service-1234567890.us-east-1.elb.amazonaws.com</span>;
<span style=color:#66d9ef>location</span> <span style=color:#e6db74>/foo/</span> {
    <span style=color:#f92672>rewrite</span> <span style=color:#e6db74>^/foo/(.*)</span> <span style=color:#e6db74>/</span>$1 <span style=color:#e6db74>break</span>;
    <span style=color:#f92672>proxy_pass</span> $upstream_endpoint;
}</code></pre></div><p>When you then make a request to <code>/foo/bar/baz</code> then the upstream will get a request for <code>/bar/baz</code> like we wanted.</p><h2 id=closing-words>Closing words</h2><p>Just to make it clear, this doesn't only affect setups using an ELB as an upstream server, but applies to any configuration where you use a changing DNS record as your upstream server in Nginx.</p><p>I hope this was useful to you. In case you have any comments to this guide or just want to get in touch with me, then find my on Twitter as <a href=https://twitter.com/Tenzer>@Tenzer</a>.</p></div></div><footer>Copyright © 2021 <a href=https://twitter.com/Tenzer>Jeppe Fihl-Pearson</a> unless otherwise noted.</footer></body></html>