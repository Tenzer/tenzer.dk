<!DOCTYPE html><html lang=en><head prefix="og: http://ogp.me/ns#"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Generating Subresource Integrity Checksums - Tenzer.dk</title><meta name=description content="The personal website and blog for Jeppe Fihl-Pearson about open source technologies and photography."><meta name=generator content="Hugo 0.62.2"><link rel=stylesheet href=/static/style.eb8df5db27.css integrity="sha256-QWp2zo3K1czNRQuaIVC4uedIqQw8b9WOS67d6jPYKDU="><link rel=logo href=/static/favicon.3dada7eb0a.svg type=image/svg+xml><link rel=icon href=/static/favicon.3dada7eb0a.svg sizes=any type=image/svg+xml><link rel=icon href=/static/favicon.e5c65e608b.png sizes=128x128 type=image/png><link rel=icon href=/static/favicon.copy.a23706216d.ico sizes="16x16 32x32 48x48 64x64" type=image/x-icon><link rel=alternate href=https://tenzer.dk/index.xml type=application/rss+xml title=Tenzer.dk><meta name=theme-color content=#2C3E50><meta property=og:type content=website><meta property=og:url content=https://tenzer.dk/generating-subresource-integrity-checksums/ ><meta property=og:site_name content=Tenzer.dk><meta property=og:title content="Generating Subresource Integrity Checksums - Tenzer.dk"><meta property=og:description content="The GitHub Engineering blog recently had a blog post on how they have added Subresource Integrity (SRI) tags on their third party assets. Long story short, this is integrity attribute you add to your <script> or <link rel=&quot;stylesheet&quot;> tags which point to external (ie. not inlined) assets. Supporting browsers will then check the checksum in the attribute against the file it has downloaded before it parses the file. This is to make sure the file hasn't been tampered with and to avoid the browser loading malicious files because some third party hoster got a security problem."><meta property=og:image content=https://tenzer.dk/images/logo.png><meta name=twitter:card content=summary><meta name=twitter:site content=@Tenzer><meta name=twitter:title content="Generating Subresource Integrity Checksums - Tenzer.dk"><meta name=twitter:description content="The GitHub Engineering blog recently had a blog post on how they have added Subresource Integrity (SRI) tags on their third party assets. Long story short, this is integrity attribute you add to your <script> or <link rel=&quot;stylesheet&quot;> tags which point to external (ie. not inlined) assets. Supporting browsers will then check the checksum in the attribute against the file it has downloaded before it parses the file. This is to make sure the file hasn't been tampered with and to avoid the browser loading malicious files because some third party hoster got a security problem."><meta name=twitter:image content=https://tenzer.dk/images/logo.png></head><body><header><div class=header-container><a href=/ ><img id=logo src=/static/tenzerdk.90021cd24c.png alt="Tenzer.dk logo"></a></div></header><div class=container><div class=content><a href=/generating-subresource-integrity-checksums/ ><h1>Generating Subresource Integrity Checksums</h1></a><p class=posted-date>Posted on September 23, 2015</p><p>The GitHub Engineering blog recently had a blog post on how they have added <a href=http://githubengineering.com/subresource-integrity/ >Subresource Integrity</a> (SRI) tags on their third party assets. Long story short, this is <code>integrity</code> attribute you add to your <code>&lt;script&gt;</code> or <code>&lt;link rel="stylesheet"&gt;</code> tags which point to external (ie. not inlined) assets. Supporting browsers will then check the checksum in the attribute against the file it has downloaded before it parses the file. This is to make sure the file hasn't been tampered with and to avoid the browser loading malicious files because some third party hoster got a security problem.</p><p>When I saw the post it was something I wanted to try out. Looking at the post from GitHub it looked like it just was a matter of creating a SHA256 checksum of a file, base64 encode it and then add <code>integrity="sha256-&lt;base64 encoded checksum&gt;"</code> to the tag of where the file was loaded. On my Mac it was just a matter of running <code>shasum --algorithm 256 &lt;file path&gt;</code> and then encode the checksum with <code>echo -n &lt;checksum&gt; | base64</code>. I prepended "sha256-" to the output, stuffed it in the integrity parameter in a HTML file, but when I tried it out in Chrome (Update! Firefox 43 and Opera 32 has since added support for SRI as well), it denied loading the file with the following error message:</p><blockquote><p>Failed to find a valid digest in the 'integrity' attribute for resource '<code>&lt;file path&gt;</code>' with computed SHA-256 integrity '<code>&lt;base64 encoded checksum&gt;</code>'. The resource has been blocked.</p></blockquote><p>A couple of questions popped into my head at this time. Why was my base64 encoded checksum double the length of the example provided in the GitHub post, and why was the checksum even base64 encoded? A SHA256 hash only consists of hexadecimal characters, so the extra encoding would only make it take up more space.</p><p>In my search for why it didn't work as expected, I found <a href=https://srihash.org/ >srihash.org</a> which is a site that can generate the integrity parameter for you. It did however generate a SHA384 checksum instead, which wasn't directly comparable to what I was testing (and required CORS enabled, which I don't get the reason for), but even their SHA384 checksum which should be longer than my SHA256 checksum, was only 64 characters compared to my 88 characters.</p><p>I found the <a href=https://github.com/mozilla/srihash.org>source code</a> for the website and saw that it depended on <a href=https://github.com/neftaly/npm-sri-toolbox>sri-toolbox</a> which was the library which generated the checksum. Looking at its source code (a Node.js library) showed this as the function that did the part I was interested in replicating:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// Generate hash
</span><span style=color:#75715e></span><span style=color:#a6e22e>digest</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>algorithm</span>, <span style=color:#a6e22e>data</span>) {
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>crypto</span>
        .<span style=color:#a6e22e>createHash</span>(<span style=color:#a6e22e>algorithm</span>)
        .<span style=color:#a6e22e>update</span>(<span style=color:#a6e22e>data</span>, <span style=color:#e6db74>'utf8'</span>)
        .<span style=color:#a6e22e>digest</span>(<span style=color:#e6db74>"base64"</span>);
},
</code></pre></div><p>I thought that looked pretty much exactly the same as what I had attempted on the command line, until it finally dawned on me that the generated checksum, before it is base64 encoded, actually is a binary blob. I have always thought of a checksum as a string of hexadecimal digits as that is how it's normally represented in checksum files and in the output from tools that can generate and check checksums. That is however just a representation of the "low level" checksum, which explains why the checksum is base64 encoded according to the SRI specifications. With this new found knowledge, I was then able to generate a correct checksum in Python that Chrome would accept.</p><p>In attempt to help out other people who may want to make use of this new technology in order to secure their users from malicious scripts, I'll try to collect some examples of how to generate the checksums needed in some different environments:</p><h2 id=shell>Shell</h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>echo -n sha256-; <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    cat &lt;input file&gt; | <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    openssl dgst -sha256 -binary | <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    base64</code></pre></div><h2 id=python>Python</h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> base64
<span style=color:#f92672>import</span> hashlib

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>checksum</span>(input):
    <span style=color:#66d9ef>if</span> isinstance(input, str):
        <span style=color:#75715e># This is so we can handle strings as input in Python 3</span>
        input <span style=color:#f92672>=</span> input<span style=color:#f92672>.</span>encode()

    hash <span style=color:#f92672>=</span> hashlib<span style=color:#f92672>.</span>sha256(input)<span style=color:#f92672>.</span>digest()
    hash_base64 <span style=color:#f92672>=</span> base64<span style=color:#f92672>.</span>b64encode(hash)<span style=color:#f92672>.</span>decode()
    <span style=color:#66d9ef>return</span> <span style=color:#e6db74></span><span style=color:#e6db74>'</span><span style=color:#e6db74>sha256-{}</span><span style=color:#e6db74>'</span><span style=color:#f92672>.</span>format(hash_base64)</code></pre></div><h2 id=nodejs>Node.js</h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>crypto</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>'crypto'</span>);

<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>checksum</span> (<span style=color:#a6e22e>input</span>) {
    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>hash</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>crypto</span>.<span style=color:#a6e22e>createHash</span>(<span style=color:#e6db74>'sha256'</span>).<span style=color:#a6e22e>update</span>(<span style=color:#a6e22e>input</span>, <span style=color:#e6db74>'utf8'</span>);
    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>hashBase64</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>hash</span>.<span style=color:#a6e22e>digest</span>(<span style=color:#e6db74>'base64'</span>);
    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>'sha256-'</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>hashBase64</span>;
}
</code></pre></div><h2 id=go>Go</h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>import</span> (
    <span style=color:#e6db74>"crypto/sha256"</span>
    <span style=color:#e6db74>"encoding/base64"</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Checksum</span>(<span style=color:#a6e22e>input</span> []<span style=color:#66d9ef>byte</span>) <span style=color:#66d9ef>string</span> {
    <span style=color:#a6e22e>hash</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sha256</span>.<span style=color:#a6e22e>Sum256</span>(<span style=color:#a6e22e>input</span>)
    <span style=color:#a6e22e>hash_base64</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>base64</span>.<span style=color:#a6e22e>StdEncoding</span>.<span style=color:#a6e22e>EncodeToString</span>(<span style=color:#a6e22e>hash</span>[:])
    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>"sha256-"</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>hash_base64</span>
}</code></pre></div><h2 id=ruby>Ruby</h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby>require <span style=color:#e6db74>'digest'</span>
require <span style=color:#e6db74>'base64'</span>

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e></span><span style=color:#f92672></span><span style=color:#a6e22e>checksum</span>(input)
    hash <span style=color:#f92672>=</span> <span style=color:#66d9ef>Digest</span><span style=color:#f92672>::</span><span style=color:#66d9ef>SHA256</span><span style=color:#f92672>.</span>digest input
    hash_base64 <span style=color:#f92672>=</span> <span style=color:#66d9ef>Base64</span><span style=color:#f92672>.</span>encode64(hash)
    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>"</span><span style=color:#e6db74>sha256-</span><span style=color:#e6db74>#{</span>hash_base64<span style=color:#e6db74>}</span><span style=color:#e6db74>"</span>
<span style=color:#66d9ef>end</span></code></pre></div><h2 id=php>PHP</h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=color:#75715e>&lt;?php</span>
<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>checksum</span>($input) {
    $hash <span style=color:#f92672>=</span> <span style=color:#a6e22e>hash</span>(<span style=color:#e6db74>'sha256'</span>, $input, <span style=color:#66d9ef>true</span>);
    $hash_base64 <span style=color:#f92672>=</span> <span style=color:#a6e22e>base64_encode</span>($hash);
    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>"sha256-</span><span style=color:#e6db74>$hash_base64</span><span style=color:#e6db74>"</span>;
}
<span style=color:#75715e>?&gt;</span>
</code></pre></div><p>I hope this was useful to you. If you want to contribute examples in other languages, then please <a href=https://twitter.com/Tenzer>let me know</a> or submit a pull request to the <a href=https://github.com/Tenzer/tenzer.dk>repository</a> for my website.</p></div></div><footer>Copyright © 2020 <a href=https://twitter.com/Tenzer>Jeppe Fihl-Pearson</a> unless otherwise noted.</footer></body></html>